"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toSQSError = exports.isConnectionError = exports.TimeoutError = exports.SQSError = void 0;
class SQSError extends Error {
    constructor(message) {
        super(message);
        this.name = this.constructor.name;
    }
}
exports.SQSError = SQSError;
class TimeoutError extends Error {
    constructor(message = 'Operation timed out.') {
        super(message);
        this.message = message;
        this.name = 'TimeoutError';
    }
}
exports.TimeoutError = TimeoutError;
/**
 * Checks if the error provided should be treated as a connection error.
 * @param err The error that was received.
 */
function isConnectionError(err) {
    if (err instanceof SQSError) {
        return (err.statusCode === 403 ||
            err.code === 'CredentialsError' ||
            err.code === 'UnknownEndpoint' ||
            err.code === 'AWS.SimpleQueueService.NonExistentQueue');
    }
    return false;
}
exports.isConnectionError = isConnectionError;
/**
 * Formats an AWSError the the SQSError type.
 * @param err The error object that was received.
 * @param message The message that the error occurred on.
 */
function toSQSError(err, message) {
    var _a, _b;
    const sqsError = new SQSError(message);
    sqsError.code = err.name;
    sqsError.statusCode = (_a = err.$metadata) === null || _a === void 0 ? void 0 : _a.httpStatusCode;
    sqsError.retryable = (_b = err.$retryable) === null || _b === void 0 ? void 0 : _b.throttling;
    sqsError.service = err.$service;
    sqsError.fault = err.$fault;
    sqsError.time = new Date();
    return sqsError;
}
exports.toSQSError = toSQSError;
