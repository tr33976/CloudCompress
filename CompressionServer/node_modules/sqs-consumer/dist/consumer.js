"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Consumer = void 0;
const client_sqs_1 = require("@aws-sdk/client-sqs");
const emitter_1 = require("./emitter");
const bind_1 = require("./bind");
const errors_1 = require("./errors");
const validation_1 = require("./validation");
const controllers_1 = require("./controllers");
const logger_1 = require("./logger");
/**
 * [Usage](https://bbc.github.io/sqs-consumer/index.html#usage)
 */
class Consumer extends emitter_1.TypedEventEmitter {
    constructor(options) {
        var _a, _b, _c, _d;
        super();
        this.pollingTimeoutId = undefined;
        this.stopped = true;
        /**
         * A reusable options object for sqs.send that's used to avoid duplication.
         */
        this.sqsSendOptions = {
            abortSignal: controllers_1.abortController.signal
        };
        (0, validation_1.assertOptions)(options);
        this.queueUrl = options.queueUrl;
        this.handleMessage = options.handleMessage;
        this.handleMessageBatch = options.handleMessageBatch;
        this.handleMessageTimeout = options.handleMessageTimeout;
        this.attributeNames = options.attributeNames || [];
        this.messageAttributeNames = options.messageAttributeNames || [];
        this.batchSize = options.batchSize || 1;
        this.visibilityTimeout = options.visibilityTimeout;
        this.terminateVisibilityTimeout =
            options.terminateVisibilityTimeout || false;
        this.heartbeatInterval = options.heartbeatInterval;
        this.waitTimeSeconds = (_a = options.waitTimeSeconds) !== null && _a !== void 0 ? _a : 20;
        this.authenticationErrorTimeout =
            (_b = options.authenticationErrorTimeout) !== null && _b !== void 0 ? _b : 10000;
        this.pollingWaitTimeMs = (_c = options.pollingWaitTimeMs) !== null && _c !== void 0 ? _c : 0;
        this.shouldDeleteMessages = (_d = options.shouldDeleteMessages) !== null && _d !== void 0 ? _d : true;
        this.sqs =
            options.sqs ||
                new client_sqs_1.SQSClient({
                    region: options.region || process.env.AWS_REGION || 'eu-west-1'
                });
        (0, bind_1.autoBind)(this);
    }
    /**
     * Creates a new SQS consumer.
     */
    static create(options) {
        return new Consumer(options);
    }
    /**
     * Start polling the queue for messages.
     */
    start() {
        if (this.stopped) {
            logger_1.logger.debug('starting');
            this.stopped = false;
            this.emit('started');
            this.poll();
        }
    }
    /**
     * Stop polling the queue for messages (pre existing requests will still be made until concluded).
     */
    stop(options) {
        if (this.stopped) {
            logger_1.logger.debug('already_stopped');
            return;
        }
        logger_1.logger.debug('stopping');
        this.stopped = true;
        if (this.pollingTimeoutId) {
            clearTimeout(this.pollingTimeoutId);
            this.pollingTimeoutId = undefined;
        }
        if (options === null || options === void 0 ? void 0 : options.abort) {
            logger_1.logger.debug('aborting');
            controllers_1.abortController.abort();
            this.emit('aborted');
        }
        this.emit('stopped');
    }
    /**
     * Returns the current polling state of the consumer: `true` if it is actively polling, `false` if it is not.
     */
    get isRunning() {
        return !this.stopped;
    }
    /**
     * Validates and then updates the provided option to the provided value.
     * @param option The option to validate and then update
     * @param value The value to set the provided option to
     */
    updateOption(option, value) {
        (0, validation_1.validateOption)(option, value, this, true);
        this[option] = value;
        this.emit('option_updated', option, value);
    }
    /**
     * Emit one of the consumer's error events depending on the error received.
     * @param err The error object to forward on
     * @param message The message that the error occurred on
     */
    emitError(err, message) {
        if (!message) {
            this.emit('error', err);
        }
        else if (err.name === errors_1.SQSError.name) {
            this.emit('error', err, message);
        }
        else if (err instanceof errors_1.TimeoutError) {
            this.emit('timeout_error', err, message);
        }
        else {
            this.emit('processing_error', err, message);
        }
    }
    /**
     * Poll for new messages from SQS
     */
    poll() {
        if (this.stopped) {
            logger_1.logger.debug('cancelling_poll', {
                detail: 'Poll was called while consumer was stopped, cancelling poll...'
            });
            return;
        }
        logger_1.logger.debug('polling');
        let currentPollingTimeout = this.pollingWaitTimeMs;
        this.receiveMessage({
            QueueUrl: this.queueUrl,
            AttributeNames: this.attributeNames,
            MessageAttributeNames: this.messageAttributeNames,
            MaxNumberOfMessages: this.batchSize,
            WaitTimeSeconds: this.waitTimeSeconds,
            VisibilityTimeout: this.visibilityTimeout
        })
            .then(this.handleSqsResponse)
            .catch((err) => {
            this.emitError(err);
            if ((0, errors_1.isConnectionError)(err)) {
                logger_1.logger.debug('authentication_error', {
                    detail: 'There was an authentication error. Pausing before retrying.'
                });
                currentPollingTimeout = this.authenticationErrorTimeout;
            }
            return;
        })
            .then(() => {
            if (this.pollingTimeoutId) {
                clearTimeout(this.pollingTimeoutId);
            }
            this.pollingTimeoutId = setTimeout(this.poll, currentPollingTimeout);
        })
            .catch((err) => {
            this.emitError(err);
        });
    }
    /**
     * Send a request to SQS to retrieve messages
     * @param params The required params to receive messages from SQS
     */
    async receiveMessage(params) {
        try {
            return await this.sqs.send(new client_sqs_1.ReceiveMessageCommand(params), this.sqsSendOptions);
        }
        catch (err) {
            throw (0, errors_1.toSQSError)(err, `SQS receive message failed: ${err.message}`);
        }
    }
    /**
     * Handles the response from AWS SQS, determining if we should proceed to
     * the message handler.
     * @param response The output from AWS SQS
     */
    async handleSqsResponse(response) {
        if ((0, validation_1.hasMessages)(response)) {
            const handlerProcessingDebugger = setInterval(() => {
                logger_1.logger.debug('handler_processing', {
                    detail: 'The handler is still processing the message(s)...'
                });
            }, 1000);
            if (this.handleMessageBatch) {
                await this.processMessageBatch(response.Messages);
            }
            else {
                await Promise.all(response.Messages.map(this.processMessage));
            }
            clearInterval(handlerProcessingDebugger);
            this.emit('response_processed');
        }
        else if (response) {
            this.emit('empty');
        }
    }
    /**
     * Process a message that has been received from SQS. This will execute the message
     * handler and delete the message once complete.
     * @param message The message that was delivered from SQS
     */
    async processMessage(message) {
        let heartbeatTimeoutId = undefined;
        try {
            this.emit('message_received', message);
            if (this.heartbeatInterval) {
                heartbeatTimeoutId = this.startHeartbeat(message);
            }
            const ackedMessage = await this.executeHandler(message);
            if ((ackedMessage === null || ackedMessage === void 0 ? void 0 : ackedMessage.MessageId) === message.MessageId) {
                await this.deleteMessage(message);
                this.emit('message_processed', message);
            }
        }
        catch (err) {
            this.emitError(err, message);
            if (this.terminateVisibilityTimeout) {
                await this.changeVisibilityTimeout(message, 0);
            }
        }
        finally {
            if (this.heartbeatInterval) {
                clearInterval(heartbeatTimeoutId);
            }
        }
    }
    /**
     * Process a batch of messages from the SQS queue.
     * @param messages The messages that were delivered from SQS
     */
    async processMessageBatch(messages) {
        let heartbeatTimeoutId = undefined;
        try {
            messages.forEach((message) => {
                this.emit('message_received', message);
            });
            if (this.heartbeatInterval) {
                heartbeatTimeoutId = this.startHeartbeat(null, messages);
            }
            const ackedMessages = await this.executeBatchHandler(messages);
            if ((ackedMessages === null || ackedMessages === void 0 ? void 0 : ackedMessages.length) > 0) {
                await this.deleteMessageBatch(ackedMessages);
                ackedMessages.forEach((message) => {
                    this.emit('message_processed', message);
                });
            }
        }
        catch (err) {
            this.emit('error', err, messages);
            if (this.terminateVisibilityTimeout) {
                await this.changeVisibilityTimeoutBatch(messages, 0);
            }
        }
        finally {
            clearInterval(heartbeatTimeoutId);
        }
    }
    /**
     * Trigger a function on a set interval
     * @param heartbeatFn The function that should be triggered
     */
    startHeartbeat(message, messages) {
        return setInterval(() => {
            if (this.handleMessageBatch) {
                return this.changeVisibilityTimeoutBatch(messages, this.visibilityTimeout);
            }
            else {
                return this.changeVisibilityTimeout(message, this.visibilityTimeout);
            }
        }, this.heartbeatInterval * 1000);
    }
    /**
     * Change the visibility timeout on a message
     * @param message The message to change the value of
     * @param timeout The new timeout that should be set
     */
    async changeVisibilityTimeout(message, timeout) {
        try {
            const input = {
                QueueUrl: this.queueUrl,
                ReceiptHandle: message.ReceiptHandle,
                VisibilityTimeout: timeout
            };
            return await this.sqs.send(new client_sqs_1.ChangeMessageVisibilityCommand(input), this.sqsSendOptions);
        }
        catch (err) {
            this.emit('error', (0, errors_1.toSQSError)(err, `Error changing visibility timeout: ${err.message}`), message);
        }
    }
    /**
     * Change the visibility timeout on a batch of messages
     * @param messages The messages to change the value of
     * @param timeout The new timeout that should be set
     */
    async changeVisibilityTimeoutBatch(messages, timeout) {
        const params = {
            QueueUrl: this.queueUrl,
            Entries: messages.map((message) => ({
                Id: message.MessageId,
                ReceiptHandle: message.ReceiptHandle,
                VisibilityTimeout: timeout
            }))
        };
        try {
            return await this.sqs.send(new client_sqs_1.ChangeMessageVisibilityBatchCommand(params), this.sqsSendOptions);
        }
        catch (err) {
            this.emit('error', (0, errors_1.toSQSError)(err, `Error changing visibility timeout: ${err.message}`), messages);
        }
    }
    /**
     * Trigger the applications handleMessage function
     * @param message The message that was received from SQS
     */
    async executeHandler(message) {
        let handleMessageTimeoutId = undefined;
        try {
            let result;
            if (this.handleMessageTimeout) {
                const pending = new Promise((_, reject) => {
                    handleMessageTimeoutId = setTimeout(() => {
                        reject(new errors_1.TimeoutError());
                    }, this.handleMessageTimeout);
                });
                result = await Promise.race([this.handleMessage(message), pending]);
            }
            else {
                result = await this.handleMessage(message);
            }
            return result instanceof Object ? result : message;
        }
        catch (err) {
            if (err instanceof errors_1.TimeoutError) {
                err.message = `Message handler timed out after ${this.handleMessageTimeout}ms: Operation timed out.`;
            }
            else if (err instanceof Error) {
                err.message = `Unexpected message handler failure: ${err.message}`;
            }
            throw err;
        }
        finally {
            if (handleMessageTimeoutId) {
                clearTimeout(handleMessageTimeoutId);
            }
        }
    }
    /**
     * Execute the application's message batch handler
     * @param messages The messages that should be forwarded from the SQS queue
     */
    async executeBatchHandler(messages) {
        try {
            const result = await this.handleMessageBatch(messages);
            return result instanceof Object ? result : messages;
        }
        catch (err) {
            if (err instanceof Error) {
                err.message = `Unexpected message handler failure: ${err.message}`;
            }
            throw err;
        }
    }
    /**
     * Delete a single message from SQS
     * @param message The message to delete from the SQS queue
     */
    async deleteMessage(message) {
        if (!this.shouldDeleteMessages) {
            logger_1.logger.debug('skipping_delete', {
                detail: 'Skipping message delete since shouldDeleteMessages is set to false'
            });
            return;
        }
        logger_1.logger.debug('deleting_message', { messageId: message.MessageId });
        const deleteParams = {
            QueueUrl: this.queueUrl,
            ReceiptHandle: message.ReceiptHandle
        };
        try {
            await this.sqs.send(new client_sqs_1.DeleteMessageCommand(deleteParams), this.sqsSendOptions);
        }
        catch (err) {
            throw (0, errors_1.toSQSError)(err, `SQS delete message failed: ${err.message}`);
        }
    }
    /**
     * Delete a batch of messages from the SQS queue.
     * @param messages The messages that should be deleted from SQS
     */
    async deleteMessageBatch(messages) {
        if (!this.shouldDeleteMessages) {
            logger_1.logger.debug('skipping_delete', {
                detail: 'Skipping message delete since shouldDeleteMessages is set to false'
            });
            return;
        }
        logger_1.logger.debug('deleting_messages', {
            messageIds: messages.map((msg) => msg.MessageId)
        });
        const deleteParams = {
            QueueUrl: this.queueUrl,
            Entries: messages.map((message) => ({
                Id: message.MessageId,
                ReceiptHandle: message.ReceiptHandle
            }))
        };
        try {
            await this.sqs.send(new client_sqs_1.DeleteMessageBatchCommand(deleteParams), this.sqsSendOptions);
        }
        catch (err) {
            throw (0, errors_1.toSQSError)(err, `SQS delete message failed: ${err.message}`);
        }
    }
}
exports.Consumer = Consumer;
